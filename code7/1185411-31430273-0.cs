    interface IHasId {
        int Id { get; set; }
    }
    
    class AutoIdList<T> where T : class, IHasId {
        private readonly IDictionary<int, T> _dictionary = new Dictionary<int, T>();
        //Using this list ensures you don't duplicate ids even
        //for an item added with an explicit id then removed
        private IList<int> _historicalIds = new List<int>();
        private int highestAutoGeneratedId = 0;
        
        public List<T> ToList() {
            return _dictionary.Values.ToList();
        }
    
        public void Add(T item, bool generateId) {
            if (generateId) {
                highestAutoGeneratedId = NextId();
                T.Id = highestAutoGeneratedId;
            }
            Add(T);
        }
        public void Replace(T item) {
            _dictionary[item.Id] = item;
        }
        public void Remove(T item) {
            _dictionary.Remove(item.Id);
        }
        private void Add(T item) {
            if (_historicalIds.Contains(T.Id)) {
                //throw an appropriate exception
            } else {
                _historicalIds.Add(T.Id);
                _dictionary.Add(T.Id, T);
            }
        }
        private int NextId() {
            var id = highestAutoGeneratedId + 1;
            while (_historicalIds.Contains(id)) {
                id++;
            }
            return id;
        }
        //More methods to simulate AddRange, Insert, etc if required. Leave if not.
        //Should all have simple logic but require checking of Id if adding anything
        //Also need logic to maintain the list of used ids
    }
