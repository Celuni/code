c#
var itemsToRemove = new string[] { "A", "B", "C" };
Here we add all the elements, which we don't want to be in the output. In our case, we remove A, B, C
 - Serialize back the Object to JSON. We use **Formatting.Indented**, so the result looks better (beautifier, human readable)
using Newtonsoft.Json;
using System;
using System.Collections.Generic;
using System.Dynamic;
using System.Linq;
using System.Text;
namespace JsonExercise
{
    public class JsonExercise
    {
        public static void Main(string[] args)
        {
            var sb = new StringBuilder();
            var line = string.Empty;
            while (!string.IsNullOrWhiteSpace((line = Console.ReadLine())))
            {
                sb.AppendLine(line);
            }
            var json = sb.ToString().Trim();
            var inputObj = JsonConvert.DeserializeObject<Base>(json);
            var resultObj = new
            {
                Type = inputObj.Type,
                Parameters = new List<object>()
            };
            Console.WriteLine("--------------------------------");
            //Here we can give all the Properties, which will be skipped!
            var itemsToRemove = new string[] { "A", "B", "C" };
            var propertiesToAdd = new Dictionary<string, object>();
            foreach (var propertyInfo in typeof(ParameterBase).GetProperties())
            {
                if (!itemsToRemove.Contains(propertyInfo.Name))
                {
                    var propertyValue = (inputObj.Parameters[0]).GetType().GetProperty(propertyInfo.Name).GetValue(inputObj.Parameters[0]);
                    propertiesToAdd.Add($"{propertyInfo.Name}", propertyValue);
                }
            }
            var objToAdd = GetDynamicObject(propertiesToAdd);
            resultObj.Parameters.Add(objToAdd);
            Console.WriteLine("Serializing Object");
            Console.WriteLine(JsonConvert.SerializeObject(resultObj, Formatting.Indented));
        }
        public static dynamic GetDynamicObject(Dictionary<string, object> properties)
        {
            return new MyDynObject(properties);
        }
    }
    public sealed class MyDynObject : DynamicObject
    {
        private readonly Dictionary<string, object> _properties;
        public MyDynObject(Dictionary<string, object> properties)
        {
            _properties = properties;
        }
        public override IEnumerable<string> GetDynamicMemberNames()
        {
            return _properties.Keys;
        }
        public override bool TryGetMember(GetMemberBinder binder, out object result)
        {
            if (_properties.ContainsKey(binder.Name))
            {
                result = _properties[binder.Name];
                return true;
            }
            else
            {
                result = null;
                return false;
            }
        }
        public override bool TrySetMember(SetMemberBinder binder, object value)
        {
            if (_properties.ContainsKey(binder.Name))
            {
                _properties[binder.Name] = value;
                return true;
            }
            else
            {
                return false;
            }
        }
    }
    public class Base
    {
        public string Type { get; set; }
        public ParameterBase[] Parameters { get; set; }
    }
    public class ParameterBase
    {
        public ParameterInfo A { get; set; }
        public ParameterInfo B { get; set; }
        public ParameterInfo C { get; set; }
        public ParameterInfo D { get; set; }
        public ParameterInfo E { get; set; }
        public DropdownInfo F { get; set; }
    }
    public class ParameterInfo
    {
        public string Type { get; set; }
        public string DefaultValue { get; set; }
    }
    public class DropdownInfo
    {
        public string Type { get; set; }
        public string DefaultValue { get; set; }
        public string[] DropDownItems { get; set; }
    }
}
The first part of the code with the StringBuilder class is just to read the input(The given JSON).
I will give sample input and output JSON data.
**--INPUT--**
json
        {
      "Type": "Name",
      "parameters": [
        {
          "A": {
            "type": "string",
            "defaultValue": "key"
          },
          "B": {
            "type": "string",
            "defaultValue": "key"
          },
          "C": {
            "type": "string",
            "defaultValue": "key"
          },
          "D": {
            "type": "string",
            "defaultValue": "autogenerated"
          },
          "E": {
            "type": "string",
            "defaultValue": "autogenerated"
          },
          "F": {
            "type": "dropdown",
            "dropDownItems": [
              "true",
              "false"
            ],
            "defaultValue": "false"
          }
        }
      ]
    }
**--OUTPUT--**
json
{
  "Type": "Name",
  "Parameters": [
    {
      "D": {
        "Type": "string",
        "DefaultValue": "autogenerated"
      },
      "E": {
        "Type": "string",
        "DefaultValue": "autogenerated"
      },
      "F": {
        "Type": "dropdown",
        "DefaultValue": "false",
        "DropDownItems": [
          "true",
          "false"
        ]
      }
    }
  ]
}
Edit: Changed the code after @João Paulo Amorim comment. I tested the code it works fine, use it freely.
Shout out to João Paulo Amorim and his answer. Looks smoother.
PS. My first answer on StackOverFlow \o/
