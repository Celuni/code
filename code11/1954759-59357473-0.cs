cs
public static class Seeds
{
    public static IEnumerable<State> States = new State[]
    {
        new State { StateName = "New South Wales", StateShortName = "NSW" },
        ⋮
    }
    public static IEnumerable<Suburb> Suburbs = new Suburb[]
    {
        new Suburb { PostCode = "200", SuburbName = "Australian National University", StateId = stateID, Latitude = -35.2777, Longditude = 149.1189 },
        ⋮
    }
}
Then if you can have it added to your migration:
cs
public class APIDbContext : DbContext
{
    protected override void OnModelCreating(ModelBuilder modelBuilder)
    {
        base.OnModelCreating(modelBuilder);
        ⋮
        modelBuilder.Entity<State>().HasData(Seeds.States);
        modelBuilder.Entity<Suburb>().HasData(Seeds.Suburbs);
    }
}
Here, you can hardcode whatever Ids you need in your `Seeds` class. As long as you never change those Ids, your seed data will persist through all migrations.
> This type of seed data is managed by migrations and the script to update the data that's already in the database needs to be generated without connecting to the database. This imposes some restrictions:
>  
> - The primary key value needs to be specified even if it's usually generated by the database. It will be used to detect data changes between migrations.
> - Previously seeded data will be removed if the primary key is changed in any way.
> 
> Therefore this feature is most useful for static data that's not expected to change outside of migrations and does not depend on anything else in the database, for example ZIP codes.
Reference: [Data Seeding][1]
  [1]: https://docs.microsoft.com/en-us/ef/core/modeling/data-seeding
