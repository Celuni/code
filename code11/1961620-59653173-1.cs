interface IFoo
{
    String Bar { get; set; }
}
Means: "`IFoo` has a **public**[1] `String` property named `Bar` which has a getter and a setter."
This:
class Foo
{
    String Bar { get; set; }
}
Means: "`Foo` has a **private** `String` property named `Bar` which has a getter and a setter, and the getter and setter are both auto-generated by the compiler and operate on a hidden instance field. (Class members are private by default).
> Is the private field in interfaces not generated the same as in classes
Interfaces don't have fields, **interfaces only have virtual methods**. Note that internally: properties and events are also fundamentally virtual methods (also note that while internally they're virtual calls, implemented interface methods are not automatically `virtual` (in the C# sense) in that a subclass of an interface implementation cannot arbitrarily `override` any interface member.
Also not to be confused with "Default interface implementations" in C# 8.0 which a more akin to extension methods than treating interfaces as classes, because interfaces still cannot have fields.
[1] Disregarding Explicit Interface Implementation, of course.
