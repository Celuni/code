interface IFoo
{
    String Bar { get; set; }
}
Means: "`IFoo` has a **public**<sub>[1]</sub> `String` property named `Bar` which has a getter and a setter."
This:
class Foo
{
    String Bar { get; set; }
}
Means: "`Foo` has a **private**<sub>[2]</sub> `String` property named `Bar` which has a getter and a setter, and the getter and setter are both auto-generated by the compiler and operate on a hidden instance field.
> Is the private field in interfaces not generated the same as in classes
Interfaces don't have fields, **interfaces only have virtual methods**. Note that internally: properties and events are also fundamentally virtual methods (also note that while internally they're virtual calls, implemented interface methods are not automatically `virtual` (in the C# sense) in that a subclass of an interface implementation cannot arbitrarily `override` any interface member.
Also not to be confused with "Default interface implementations" in C# 8.0 which a more akin to extension methods than treating interfaces as classes, because interfaces still cannot have fields.
[1] Disregarding Explicit Interface Implementation, of course.  
[2] Class members are private by default if they don't have an explicit access-modifier.
