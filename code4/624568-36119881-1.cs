    using System;
    using System.Collections.Generic;
    using System.Diagnostics;
    using System.IO;
    using System.Linq;
    using System.Reflection;
    using System.Text;
    using System.Text.RegularExpressions;
    using System.Threading.Tasks;
    public class ClassCaller
    {
        Type type;
        object o;
        bool throwOnError;
        /// <summary>
        /// Useful for static method calling within assembly / class.
        /// </summary>
        /// <param name="assemblyName">Assembly name</param>
        /// <param name="className">Class name, including namespace</param>
        /// <param name="_throwOnError">true if throw on error</param>
        public ClassCaller(String assemblyName, String className, bool _throwOnError)
        {
            throwOnError = _throwOnError;
            Assembly asm = AppDomain.CurrentDomain.GetAssemblies().Where(x => x.GetName().Name == assemblyName).FirstOrDefault();
            if (asm == null)
            {
                if (_throwOnError)
                    throw new NullReferenceException("Assembly with name '" + assemblyName + "' was not found");
                return;
            }
            type = asm.GetType(className, _throwOnError);
        }
        public ClassCaller(object _o)
        {
            type = _o.GetType();
            o = _o;
        }
        /// <summary>
        /// Gets method to invoke. 
        /// </summary>
        /// <param name="func">Function name to get. Use '!' as a prefix if it's static function.</param>
        /// <param name="types">Function argument types.</param>
        /// <returns>Method to be invoked.</returns>
        public MethodInfo GetFunc(String func, Type[] types)
        {
            bool bIsStatic = func.FirstOrDefault() == '!';
            if (bIsStatic) func = func.Substring(1);
            BindingFlags f = BindingFlags.Public | BindingFlags.NonPublic;
            if (!bIsStatic)
                f |= BindingFlags.Instance;
            else
                f |= BindingFlags.Static;
            MethodInfo m = type.GetMethod(func, f, null, types, null);
            if (m == null && throwOnError)
                throw new NotSupportedException("Compatible function '" + func + "' not found");
            return m;
        }
        //Autogenerated code starts (Do not edit)
        public object DoCall(string func)
        {
            Type[] types = new Type[] { };
            object[] args = new object[] { };
            MethodInfo f = GetFunc(func, types);
            if (f == null)
                return null;
            object r = f.Invoke(o, args);
            return r;
        }
        public object DoCall<A1>(string func, A1 a1)
        {
            Type[] types = new Type[] { typeof(A1) };
            object[] args = new object[] { a1 };
            MethodInfo f = GetFunc(func, types);
            if (f == null)
                return null;
            object r = f.Invoke(o, args);
            return r;
        }
        public object DoCall<A1>(string func, ref A1 a1)
        {
            Type[] types = new Type[] { typeof(A1).MakeByRefType() };
            object[] args = new object[] { a1 };
            MethodInfo f = GetFunc(func, types);
            if (f == null)
                return null;
            object r = f.Invoke(o, args);
            a1 = (A1)args[0];
            return r;
        }
        public object DoCall<A1, A2>(string func, A1 a1, A2 a2)
        {
            Type[] types = new Type[] { typeof(A1), typeof(A2) };
            object[] args = new object[] { a1, a2 };
            MethodInfo f = GetFunc(func, types);
            if (f == null)
                return null;
            object r = f.Invoke(o, args);
            return r;
        }
        public object DoCall<A1, A2>(string func, ref A1 a1, A2 a2)
        {
            Type[] types = new Type[] { typeof(A1).MakeByRefType(), typeof(A2) };
            object[] args = new object[] { a1, a2 };
            MethodInfo f = GetFunc(func, types);
            if (f == null)
                return null;
            object r = f.Invoke(o, args);
            a1 = (A1)args[0];
            return r;
        }
        public object DoCall<A1, A2>(string func, A1 a1, ref A2 a2)
        {
            Type[] types = new Type[] { typeof(A1), typeof(A2).MakeByRefType() };
            object[] args = new object[] { a1, a2 };
            MethodInfo f = GetFunc(func, types);
            if (f == null)
                return null;
            object r = f.Invoke(o, args);
            a2 = (A2)args[1];
            return r;
        }
        public object DoCall<A1, A2>(string func, ref A1 a1, ref A2 a2)
        {
            Type[] types = new Type[] { typeof(A1).MakeByRefType(), typeof(A2).MakeByRefType() };
            object[] args = new object[] { a1, a2 };
            MethodInfo f = GetFunc(func, types);
            if (f == null)
                return null;
            object r = f.Invoke(o, args);
            a1 = (A1)args[0];
            a2 = (A2)args[1];
            return r;
        }
        //Autogenerated code ends
        public static void UpdateSourceCodeHelperFunctions( int nParametersToSupport)
        {
            String srcFilename = new StackTrace(true).GetFrame(0).GetFileName();
            String src = File.ReadAllText(srcFilename, Encoding.UTF8);
            String autogenRegex = "(Autogenerated\\scode\\sstarts.*?[\r\n]{2})(.*)([\r\n]{2}\\s+//Autogenerated\\scode\\sends)";
            if (!Regex.Match(src, autogenRegex, RegexOptions.Singleline).Success)
            {
                Console.WriteLine("Error: Invalid source code");
                return;
            }
            string[] argType = new String[] { "", "ref" };
            String s = "";
            string lf = "\r\n";
            string headSpace = "    ";
            for (int callArgs = 0; callArgs <= nParametersToSupport; callArgs++)
            {
                int[] argTypes = new int[callArgs];
                int iterations = (int)Math.Pow(2, callArgs);
                for (int i = 0; i < iterations; i++)
                {
                    //public object DoCall<A1, A2>(String func, A1 a1, A2 a2)
                    s += headSpace;
                    s += "public object DoCall" + ((callArgs != 0) ? "<" : "");
                    s += String.Join(", ", Enumerable.Range(1, callArgs).Select(n => "A" + n));
                    s += (callArgs != 0) ? ">" : "";
                    s += "(string func";
                    String types = "";
                    String paramsList = "";
                    bool[] isRefType = new bool[callArgs];
                    for (int iArg = 0; iArg < callArgs; iArg++)
                    {
                        isRefType[iArg] = (((1 << iArg) & i) != 0);
                        String isRef = isRefType[iArg] ? "ref " : "";
                        String argTypeName = "A" + (iArg + 1);
                        String argName = "a" + (iArg + 1);
                        s += ", ";
                        s += isRef;
                        s += argTypeName + " " + argName;
                        if (iArg != 0)
                        {
                            types += ", ";
                            paramsList += ", ";
                        }
                        types += "typeof(" + argTypeName + ")";
                        if (isRefType[iArg])
                            types += ".MakeByRefType()";
                        paramsList += argName;
                    } //for
                    s += ")";
                    s += lf;
                    s += headSpace + "{" + lf;
                    //Type[] types = new Type[] { typeof(A1).MakeByRefType() };
                    s += headSpace + "    ";
                    if( types.Length != 0 ) types += " ";
                    s += "Type[] types = new Type[] { " + types + "};";
                    s += lf;
                    //object[] args = new object[] { a1 };
                    s += headSpace + "    ";
                    if( paramsList.Length != 0 ) paramsList += " ";
                    s += "object[] args = new object[] { " + paramsList + "};";
                    s += lf;
                    //MethodInfo f = GetFunc(func, types);
                    //if (f == null)
                    //    return null;
                    //object r = f.Invoke(o, args);
                    s += headSpace + "    MethodInfo f = GetFunc(func, types);" + lf;
                    s += headSpace + "    if (f == null)" + lf;
                    s += headSpace + "        return null;" + lf;
                    s += headSpace + "    object r = f.Invoke(o, args);" + lf;
                    for (int iArg = 0; iArg < callArgs; iArg++)
                    {
                        if (!isRefType[iArg])
                            continue;
                        // a1 = (A1)args[0];
                        String argTypeName = "A" + (iArg + 1);
                        String argName = "a" + (iArg + 1);
                        s += headSpace + "    ";
                        s += argName + " = (" + argTypeName + ")args[" + iArg + "];";
                        s += lf;
                    }
                    s += headSpace + "    return r;" + lf;
                    s += headSpace + "}" + lf;
                    s += lf;
                }
            } //for
            String oldautogenCode = Regex.Match(src, autogenRegex, RegexOptions.Singleline).Groups[2].Value;
            //
            // Visual studio text editor configuration affects spacing. We trim here everything so we can compare output.
            //
            oldautogenCode = oldautogenCode.Replace(" ", "").TrimStart('\r','\n');
            String newautogenCode = s.Replace(" ", "").TrimStart('\r', '\n');
        
            String newSrc = Regex.Replace(src, autogenRegex, "$1\r\n" + s + "$3", RegexOptions.Singleline);
            if (oldautogenCode == newautogenCode)
            {
                Console.WriteLine("Source code is up-to-date.");
            }
            else
            {
                File.WriteAllText(srcFilename, newSrc, Encoding.UTF8);
            }
        } //UpdateSourceCodeHelperFunctions
    } //class ClassCaller
