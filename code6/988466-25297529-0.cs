    var context = new MyDbcontext();
    var root = context
                               .Roots
                               .LoadAggregation()
                               .ToList();
                               //    LoadAggregation in this case, means following codes:   
                               //    .Include("Child1")   
                               //    .Include("Child2")
    
    root.Child1.Remove(child11);
    root.Child1.Add(Child13); // 
    root.Child2.Add(Child22);
    using(var uow = new UnitOfWork())   
    {
        uow.Repository<Root>().Update(root, context);
        uow.Repository<AnotherRoot>().Update(anotherRoot, context); //user may want to update multiple Roots
        uow.SaveChanges(context);   <---- at this point Child13.Id and  Child22.Id generated by Db
    }
    public void Update(Root entity, MyDbcontext context) //Update method in my Repository class
    { 
       var savedEntity = context.Roots //reload entity graph from db
                                .LoadAggregation()
                                .ToList();
       Mapper.Map(entity,savedEntity); // map user changes to original graph
       context.UpdateGraph(savedEntity, savedEntity.MappingConfiguration); // attach updated entity to dbcontext using graphdiff
    } 
    public void SaveChanges(context) // SaveChanges() in UnitofWork class
    {  
      context.SaveChanges();
    }
