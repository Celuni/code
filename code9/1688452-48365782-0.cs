    public async Task<OutputDto> Update(InputDto input)
    {
        // First get a real entity by Id from the repository
        // This repository method returns: 
        // Context.Masters
        //    .Include(x => x.SuperMaster)
        //    .Include(x => x.Children)
        //    .ThenInclude(x => x.RelatedEntity)
        //    .FirstOrDefault(x => x.Id == id)
        Master entity = await _masterRepository.Get(input.Id);
        // Update the master entity properties manually
        entity.SomeProperty = "Updated value";
        // Prepare a list for any children with modified RelatedEntity
        var changedChildren = new List<Child>();
        foreach (var child in input.Children)
        {
            // Check to see if this is a new child item
            if (entity.Children.All(x => x.Id != child.Id))
            {
                // Map the DTO to child entity and add it to the collection
                entity.Children.Add(Mapper.Map<Child>(child));
                continue;
            }
            // Check to see if this is an existing child item
            var existingChild = entity.Children.FirstOrDefault(x => x.Id == child.Id);
            if (existingChild == null)
            {
                continue;
            }
            // Check to see if the related entity was changed
            if (existingChild.RelatedEntity.Id != child.RelatedEntity.Id)
            {
                // It was changed, add it to changedChildren list
                changedChildren.Add(existingChild);
                continue;
            }
 
            // It's safe to use AutoMapper to map the child entity and avoid updating properties manually, 
            // provided that it doesn't have child-items of their own
            Mapper.Map(dio, stariDio);
        }
        // Find which of the child entities should be deleted
        // entity.IsTransient() is an extension method which returns true if the entity has just been added
        foreach (var child in entity.Children.Where(x => !x.IsTransient()).ToList())
        {
            if (input.Children.Any(x => x.Id == child.Id))
            {
                continue;
            }
            // We don't have this entity in the list sent by the client.
            // That means we should delete it
            await _childRepository.DeleteAsync(child);
            entity.Children.Remove(child);
        }
        // Parse children entities with modified related entities
        foreach (var child in changedChildren)
        {
            var newChild = input.Children.FirstOrDefault(x => x.Id == child.Id);
            // Delete the existing one
            await _childRepository.DeleteAsync(child);
            entity.Children.Remove(child);
            // Add the new one
            // It's OK to change the primary key here, as this one is a DTO, not a tracked entity,
            // and besides, if the keys are autogenerated by the database, we can't have anything but 0 for a new entity
            newChild.Id = 0;
            entity.Djelovi.Add(Mapper.Map<Child>(newChild)); 
        }
        // And finally, call the repository update and return the result mapped to DTO
        entity = await _repository.UpdateAsync(entity);
        return MapToEntityDto(entity);
    }
