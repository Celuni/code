    public class DTOGeneratorRule
        {
            #region Members
        
            protected Random _random;
            protected readonly Dictionary<Type, Func<object>> typeToRandomizerFuncMap = new Dictionary<Type, Func<object>>
            {
            };
            #endregion
            #region Constructors
            public DTOGeneratorRule()
            {
                // Do Not Change this
                // This is explicitly set to assure that values are generated the same for each test
                _random = new Random(123); 
 
                typeToRandomizerFuncMap.Add(typeof(int), () => _random.Next());
                typeToRandomizerFuncMap.Add(typeof(bool), () => _random.Next() % 2 == 0);
                // Most codes on our system have a limit of 10, this should be fixed when configuration exits
                typeToRandomizerFuncMap.Add(typeof(Guid), () => Guid.NewGuid());
                typeToRandomizerFuncMap.Add(typeof(string), () => _random.GetRandomAlphanumericCode(10));
                //Most of the times we need to work with dates anyway so truncate the time
                typeToRandomizerFuncMap.Add(typeof(DateTime), () =>  DateTime.Now.Date);
                typeToRandomizerFuncMap.Add(typeof(Char), () =>_random.GetRandomAlphanumericCode(1)[0]);
                typeToRandomizerFuncMap.Add(typeof(Double), () => _random.NextDouble());
                typeToRandomizerFuncMap.Add(typeof(float), () => _random.NextFloat());
                typeToRandomizerFuncMap.Add(typeof(Decimal), () => _random.NextDecimal());
            }
            #endregion
            #region Public Methods
            public T SetAutoGeneratedDTOValues<T>(IEnumerable<Action<T>> explicitValueSetters = null, Dictionary<string, Type> typeCaster = null)
                where T : new()
            {
                T initialDTO = new T();
                return this.SetAutoGeneratedDTOValues<T>(initialDTO, explicitValueSetters, typeCaster);
            }
            public T SetAutoGeneratedDTOValues<T>(T initialDTO, IEnumerable<Action<T>> explicitValueSetters = null, Dictionary<string, Type> typeCaster = null)
            {
                if (null == initialDTO)
                {
                    throw new ArgumentNullException(nameof(initialDTO));
                }
                //TODO: This needs to work with Members as well
                foreach (var property in typeof (T).GetProperties())
                {
                    if (null == property.GetSetMethod())
                    {
                        continue;
                    }
                    object value = null;
                    Type propertyType = property.PropertyType;
                    if (propertyType.IsGenericType && propertyType.GetGenericTypeDefinition() == typeof(Nullable<>))
                    {
                        propertyType = Nullable.GetUnderlyingType(propertyType);
                    }
                    var targetType = propertyType;
                    if (typeCaster != null && typeCaster.ContainsKey(property.Name))
                    {
                        targetType = typeCaster.Get(property.Name);
                    }
                    value = this.GetRandomValue(targetType);
                    value = this.convertToType(value, propertyType);
                    property.SetValue(initialDTO, value);
                }
                if (null != explicitValueSetters)
                {
                    foreach (var setter in explicitValueSetters)
                    {
                        setter.Invoke(initialDTO);
                    }
                }
                return initialDTO;
            }
            #endregion
            #region Protected Methods
            protected object convertToType(object value, Type type)
            {
                return Convert.ChangeType(value, type);
            }
            protected bool TryGetRandomValue(Type type, out object value)
            {
                Func<object> getValueFunc;
                if (type.IsEnum)
                {
                    var values = Enum.GetValues(type);
                    int index = _random.Next(0, values.Length);
                    value = values.GetValue(index);
                    return true;
                }
                if (typeToRandomizerFuncMap.TryGetValue(type, out getValueFunc))
                {
                    value = getValueFunc();
                    return true;
                }
                value = null;
                return false;
            }
            protected object GetRandomValue(Type type)
            {
                object value = null;
                Func<object> getValueFunc;
                if (type.IsEnum)
                {
                    var values = Enum.GetValues(type);
                    int index = _random.Next(0, values.Length);
                    value = values.GetValue(index);
                }
                else if (typeToRandomizerFuncMap.TryGetValue(type, out getValueFunc))
                {
                    value = getValueFunc();
                }
                else
                {
                    value = this.getDefault(type);
                }
                return value;
            }
            protected object getDefault(Type type)
            {
                if (type.IsValueType)
                {
                    return Activator.CreateInstance(type);
                }
                return null;
            }
            #endregion
        }
